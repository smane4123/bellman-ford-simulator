<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bellman-Ford Simulation</title>
  <style>
    :root {
      --primary-color: #4a6fa5;
      --secondary-color: #6b8cae;
      --accent-color: #ff7e5f;
      --light-bg: #f8f9fa;
      --dark-text: #2c3e50;
      --light-text: #ecf0f1;
      --border-color: #dfe6e9;
      --success-color: #2ecc71;
      --error-color: #e74c3c;
    }
  
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: var(--dark-text);
      background-color: antiquewhite;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
  
    h1, h2, h3 {
      color: var(--primary-color);
      margin-bottom: 0.8em;
    }
  
    h1 {
      border-bottom: 2px solid var(--secondary-color);
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
  
    input {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 14px;
      transition: border 0.3s ease;
    }
  
    input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(74, 111, 165, 0.2);
    }
  
    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
  
    button:hover {
      background-color: var(--secondary-color);
      transform: translateY(-1px);
    }
  
    button:active {
      transform: translateY(0);
    }
  
    button:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(74, 111, 165, 0.4);
    }
  
    .output {
      margin-top: 30px;
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
  
    .edge-list {
      margin: 20px 0;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      background-color: white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }
  
    .edge-list h3 {
      color: var(--secondary-color);
      margin-top: 0;
    }
  
    .edge-list ul {
      list-style-type: none;
      padding-left: 0;
    }
  
    .edge-list li {
      padding: 8px 0;
      border-bottom: 1px dashed var(--border-color);
    }
  
    .edge-list li:last-child {
      border-bottom: none;
    }
  
    .step-log {
      background-color: #f5f7fa;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow-x: auto;
    }
  
    .step-log p {
      margin: 5px 0;
    }
  
    svg {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin: 20px 0;
      background-color: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      display: block;
    }
  
    .node {
      fill: var(--primary-color);
      stroke: white;
      stroke-width: 2px;
      transition: fill 0.3s ease;
    }
  
    .node:hover {
      fill: var(--accent-color);
    }
  
    .edge {
      stroke: var(--secondary-color);
      stroke-width: 2px;
    }
  
    .label {
      font-size: 14px;
      text-anchor: middle;
      font-weight: bold;
      fill: white;
    }
  
    .edge-label {
      font-size: 12px;
      fill: var(--dark-text);
      font-weight: bold;
    }
  
    /* Responsive design */
    @media (max-width: 768px) {
      body {
        padding: 15px;
      }
      
      input, button {
        width: 100%;
        margin: 5px 0;
      }
      
      svg {
        width: 100%;
        height: auto;
      }
    }
  
    /* Animation for algorithm steps */
    @keyframes highlight {
      0% { background-color: rgba(255, 126, 95, 0.1); }
      100% { background-color: transparent; }
    }
  
    .highlight {
      animation: highlight 1.5s ease;
    }
  
    /* Tooltip style */
    .tooltip {
      position: absolute;
      background-color: var(--dark-text);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <h1>Bellman-Ford Algorithm (Single Source Shortest Path)</h1>

  <div>
    <h3>Enter Edge (From, To, Weight)</h3>
    <input type="text" id="from" placeholder="From (e.g., A)">
    <input type="text" id="to" placeholder="To (e.g., B)">
    <input type="number" id="weight" placeholder="Weight (e.g., 5)">
    <button onclick="addEdge()">Add Edge</button>
  </div>

  <div class="edge-list">
    <h3>Graph Edges</h3>
    <ul id="edgeDisplay"></ul>
  </div>

  <svg id="graphCanvas" width="600" height="400"></svg>

  <p>Click the button below to run Bellman-Ford on the graph above.</p>
  <input type="text" id="source" placeholder="Source Node (e.g., A)">
  <button onclick="runBellmanFord()">Run Algorithm</button>

  <div class="output" id="output"></div>

  <script>
    const edges = [];

    function addEdge() {
      const from = document.getElementById('from').value.trim();
      const to = document.getElementById('to').value.trim();
      const weight = parseInt(document.getElementById('weight').value);

      if (!from || !to || isNaN(weight)) {
        alert('Please fill all edge fields correctly.');
        return;
      }

      edges.push([from, to, weight]);
      const li = document.createElement('li');
      li.textContent = `${from} → ${to}, weight = ${weight}`;
      document.getElementById('edgeDisplay').appendChild(li);

      document.getElementById('from').value = '';
      document.getElementById('to').value = '';
      document.getElementById('weight').value = '';

      drawGraph();
    }

    function drawGraph() {
      const svg = document.getElementById('graphCanvas');
      svg.innerHTML = '';
      const vertices = Array.from(new Set(edges.flatMap(([u, v]) => [u, v])));
      const positions = {};
      const radius = 20;
      const centerX = 300;
      const centerY = 200;
      const angleStep = (2 * Math.PI) / vertices.length;

      vertices.forEach((v, i) => {
        const angle = i * angleStep;
        const x = centerX + 150 * Math.cos(angle);
        const y = centerY + 150 * Math.sin(angle);
        positions[v] = { x, y };

        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", radius);
        circle.setAttribute("class", "node");
        svg.appendChild(circle);

        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", x);
        label.setAttribute("y", y + 5);
        label.setAttribute("class", "label");
        label.textContent = v;
        svg.appendChild(label);
      });

      const edgeCount = {};

      edges.forEach(([u, v, w]) => {
        const x1 = positions[u].x;
        const y1 = positions[u].y;
        const x2 = positions[v].x;
        const y2 = positions[v].y;

        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy);

        const key = `${u}-${v}`;
        if (!edgeCount[key]) edgeCount[key] = 0;
        edgeCount[key]++;

        const offset = 10 * edgeCount[key];
        const mx = (x1 + x2) / 2 - offset * dy / len;
        const my = (y1 + y2) / 2 + offset * dx / len;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("class", "edge");
        svg.appendChild(line);

        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", mx);
        label.setAttribute("y", my);
        label.setAttribute("class", "label");
        label.textContent = w;
        svg.appendChild(label);
      });
    }

    function runBellmanFord() {
      const source = document.getElementById('source').value.trim();
      if (!source) {
        alert('Please enter a valid source node.');
        return;
      }

      const vertices = Array.from(new Set(edges.flatMap(([u, v]) => [u, v])));
      const dist = {};
      const output = document.getElementById('output');
      output.innerHTML = '';

      const logDiv = document.createElement('div');
      logDiv.className = 'step-log';
      output.appendChild(logDiv);

      vertices.forEach(v => dist[v] = Infinity);
      dist[source] = 0;

      logDiv.innerHTML += `<p>Initial distances from source ${source}: ${JSON.stringify(dist)}</p>`;

      for (let i = 0; i < vertices.length - 1; i++) {
        logDiv.innerHTML += `<p><strong>Iteration ${i + 1}:</strong></p>`;
        let stepChanges = [];

        edges.forEach(([u, v, w]) => {
          const oldDist = dist[v];
          if (dist[u] !== Infinity && dist[u] + w < dist[v]) {
            dist[v] = dist[u] + w;
            stepChanges.push(`${u} → ${v} updated: ${oldDist} → ${dist[v]}`);
          }
        });

        if (stepChanges.length === 0) {
          logDiv.innerHTML += `<p>No updates in this iteration.</p>`;
        } else {
          stepChanges.forEach(change => {
            logDiv.innerHTML += `<p>${change}</p>`;
          });
        }
      }

      let hasNegativeCycle = false;
      edges.forEach(([u, v, w]) => {
        if (dist[u] !== Infinity && dist[u] + w < dist[v]) {
          hasNegativeCycle = true;
        }
      });

      if (hasNegativeCycle) {
        output.innerHTML += '<p style="color: red;">Graph contains a negative weight cycle!</p>';
      } else {
        output.innerHTML += `<h3>Final shortest distances from source "${source}":</h3>`;
        for (const [node, distance] of Object.entries(dist)) {
          output.innerHTML += `<p>${source} → ${node}: ${distance}</p>`;
        }
      }
    }
  </script>
</body>
</html>
